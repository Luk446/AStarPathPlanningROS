
    def astar(self, graph, start, goal):
        """
        Perform A Star's algorithm to find the shortest path from start to goal.
        
        Need to define a heuristic func and the logic for the algo
        - using euclidian as we want to include diagonals
    
        - using heapq module for processing
        - defining three list 

        """

        # importing heapq for priority queue
        import heapq

        def heuristic(a, b):
            # Euclidean distance heuristic suitable for 8-connected grids
            return math.hypot(a[0] - b[0], a[1] - b[1])
        
        if start == goal: # check if start and goal are the same
            return True, [start]

        # define the three lists
        open_heap = [] # use processing queue
        visited = set() # fully explored nodes
        parent = {} # to reconstruct path
        g_score = {start: 0} # cost from start to current node

        # init heap 
        start_f = heuristic(start, goal) # f = g + h
        heapq.heappush(open_heap, (start_f, 0, start)) # push start node with f score

        # main loop
        while open_heap: # continue until goal or nothing left
            
            f, g, current = heapq.heappop(open_heap) # get node with lowest f score

            # skip stale entries (older, worse g for same node)
            if g != g_score.get(current, float('inf')):
                continue

            # skip if a 'bad' node
            if current in visited:
                continue

            visited.add(current) # mark as fully explored

            # test for the goal
            if current == goal:
                return True, self.backtrace(parent, start, goal) # found it!
            
            # iterate over the connected neighbours
            for neighbor, step_cost in graph.get(current, []):
                if neighbor in visited: # dont go to closed nodes
                    continue

                # movement cost (orthogonal = 1, diagonal = sqrt(2))
                tentative_g = g_score[current] + step_cost


                if tentative_g < g_score.get(neighbor, float('inf')):

                    parent[neighbor] = current # record path
                    g_score[neighbor] = tentative_g # update best 
                    f_neighbor = tentative_g + heuristic(neighbor, goal)
                    heapq.heappush(open_heap, (f_neighbor, tentative_g, neighbor))

        
        # No path found
        return False, []
